#!/usr/bin/perl

use Term::ReadKey;
use Term::ANSIColor qw(uncolor colored);
use Time::HiRes qw( gettimeofday tv_interval );
use Getopt::Long;

use DBI;
$clear = "\033[H\033[2J";

my $conf;
my $user;
my $pass;
$conf = "$ENV{HOME}/.mmtop_config";
$result = GetOptions ("password=s" => \$pass,    # numeric
                        "user=s"   => \$user, 
			"config=s" => \$conf);  # flag


# how long before a query is treated as part of a wedge
$wedge_time_threshold = 10;
# how many queries running simultaneously to be considered a wedge
$wedge_num_queries = 5;


@hosts = ();
my %no_slave;
my %comments;
my %wedge;
my %delimiters;
my %qps;
$log_dir = "$ENV{HOME}/.mmtop_log";

open(CONF, "$conf" ) || die("Couldn't open config file $conf...\n");

while (<CONF>) {
	chomp;
	$_ =~ s/^\s+//g;
	$_ =~ s/\s+$//g;
	($opt, $val) = split(/\s+/, $_);
	if ( lc($opt) eq 'host' ) {
		$this_host = $val;
		push(@hosts, $this_host);
	} elsif (lc($opt eq 'no-slave')) {
		$idx = $hosts[@hosts - 1];
		$no_slave{$idx} = 1;
	} elsif (lc($opt eq 'comment')) {
		$idx = $hosts[@hosts - 1];
		$comments{$idx} = $val;
	} elsif (lc($opt eq 'wedge')) {
		$idx = $hosts[@hosts - 1];
		$wedge{$idx} = ($val eq 'on');
	} elsif (lc($opt eq 'delimiter')) {
		$idx = $hosts[@hosts - 1];
		$delimiters{$idx} = $val;
	} elsif (lc($opt) eq 'database') {
		$database = $val;
	} elsif (lc($opt) eq 'password') {
		$pass = $val unless $pass;
	} elsif (lc($opt) eq 'user') {
		$user = $val unless $user;
	} elsif (lc($opt) eq 'logdir') {
		$log_dir = $val;
	}
}

$0 = "mmtop";

%cxs = {};

$SIG{ALRM} = sub {};
foreach $h (@hosts) {              
	print "Connecting to " . $h . "\n";

	$cxs{$h} = DBI->connect("DBI:mysql:$database:$h", $user, $pass, {mysql_connect_timeout => 2});
}

print "\033]0;mysql monitor\007";

sub short_query()
{
	my $q = $_[0];
	my $len = $_[1];
	$q =~ s/\n\s*/ /g;
	$q =~ s/[[:cntrl:]]//g;
	$q = substr($q, 0, $len);
	return $q;
}

sub dump_wedge()
{
	my $server = $_[0];
	my $processes = $_[1];
	$now = `date +'%m%d%Y_%H%M%S'`;
	chomp $now;
	open(WEDGE, ">$log_dir/$server" . "_" . "$now");
	#print ">$log_dir/$server" . "_" . "$now";
	my @sorted = sort { $b->{"Time"} <=> $a->{"Time"} } @$processes;
	foreach $p(@sorted) {	
		my $query = $p->{"Info"};
		my $time = $p->{"Time"};
		next if ($query eq '' || $query eq 'NULL' || $query eq 'show full processlist');
		next if ($query =~ /get_lock/);
		print WEDGE $time . "\t" . $query . "\n";
	}
	my @status = $cxs{$server}->selectrow_array("show innodb status");
	print WEDGE join(" ", @status);
	close(WEDGE);
}

sub detect_wedge()
{
	my $server = $_[0];
	my $processes = $_[1];

	my $long_query_count;
	foreach $p(@$processes) {	
		my $query = $p->{"Info"};
		my $time = $p->{"Time"};
		next if ($query eq '' || $query eq 'NULL' || $query eq 'show full processlist');
		next if ($query =~ /get_lock/);
		next if ($time < $wedge_time_threshold);
		$long_query_count++;
	}
	if ( $long_query_count > $wedge_num_queries ) {
		&dump_wedge($server, $processes);
	}
}


my $long_running_queries = 0;

sub print_mysql()
{
	my %queries;
	my %dbs;

	my $server = $_[0];
	$processes = $_[1];

	my ($line, $command, $host, $state, $time, $db, $query, $short_query);
	my @output = ();
	my $truncate = int($TERM_COLS);
	foreach $p (@$processes)  {
		$id = $p->{"Id"};
		$command = $p->{"Command"};
		$host = $p->{"Host"};
		$state = $p->{"State"};
		$time = $p->{"Time"};
		$db = $p->{"Db"};
		$query = $p->{"Info"};
		$short_query = &short_query($query, $truncate - 17);

		next unless ($command eq 'Query' || $command eq 'Connect');
		next if ($query eq '' || $query eq 'NULL' || $query eq 'show full processlist');
		next if ($query =~ /get_lock/);
		next if ($long_running_only && $time < $long_running_only);
		$queries{$id}{'q'} = $query;
		$queries{$id}{'real_id'} = $p->{"real_id"};
		$queries{$id}{'db'} = $db;
		$queries{$id}{'host'} = $host;
		$queries{$id}{'state'} = $state;
		$queries{$id}{'server'} = $server;
		$queries{$id}{'time'} = $time;
		$short_query = colored($short_query, "white bold") if ($time > 2 && $short_query !~ /^insert|update|delete/i );
		$raw_time = $time;
		if ( $time >= 360000 ) {
			$time = int ($time / (60 * 60 * 24)) . "d";
		} elsif ( $time >= 3600 ) {
			$time /= (60 * 60);
			$time = int($time);
			$time .= "h";
		} elsif ( $time >= 1000 ) {
			$time /= 60;
			$time = int($time);
			$time .= "m";
		}
		my $tmp = [$raw_time, sprintf "|%3s|%5s| %s", $time, $id, $short_query . " "];
		push @output, $tmp;
	}
	my @sorted = sort { $$b[0] <=> $$a[0] } @output;
	my $count = 0;
	my $last;
	foreach $l (@sorted) {
		print $$l[1];
		print colored("", "reset");
                printf "%*s|\n", $truncate - &precolor_length($$l[1])  - 1;

		$last = $l;
	}
	return \(%queries, %dbs);
}

sub precolor_length()
{
	$str = $_[0];
	$str =~ s/\e.*?m//g;
	return length($str);
}

$rin = $ein = '';
vec($rin,fileno(STDIN),1) = 1;
$ein = $rin;

ReadMode cbreak;
$| = 1;

$quit = 0;
while ( $quit == 0 ) {
	($TERM_COLS,$termlines)=GetTerminalSize();

	print $clear;


	$| = 0;

	print "+";

	for ( $i = 0 ; $i < ($TERM_COLS - 2); $i++ ) {
		printf "-";
	}
	print "+\n";
	$now = `date`;
	chomp($now);
	printf "|%3s|%5s| %*s|\n", "tm", "pid", -($TERM_COLS - 13), "Query | " . $now;
	my ($queries, $dbs);
	$pid_map = 0;
	foreach $host (@hosts) {
		$host_str = "|---|-----| ";
		if ( $delimiters{$host} ) {
			print "|";
			print colored("---", "cyan bold");
			print "|";
			print colored("-----", "cyan bold");
			print "| ";
			print colored($delimiters{$host}, "white bold");
			print "\n";
		}
		if (!$cxs{$host}) {
			printf $host_str;
			print colored("*** $host down ***\n", "red");
			next;
		}
		$save_host = $host;
		printf $host_str;
		
		$host_line = colored($host, 'white'); 
		if ( !$no_slave{$host} ) {
			alarm(2);
			$handle = $cxs{$host}->prepare("show slave status");
			$handle->execute();
			alarm(0);    
			$slave_status = $handle->fetchrow_hashref();

			$io = $slave_status->{'Slave_IO_Running'};		
			$sql = $slave_status->{'Slave_SQL_Running'};		
			$behind = $slave_status->{'Seconds_Behind_Master'};

			if ( $behind <= 5 ) {
				$color = "white";
			} elsif ( $behind < 120 ) {
				$color = "yellow bold";
			} else {
				$color = "red bold";
			}

			$slave_part = " " . colored($behind, $color);
			if ( $io ne 'Yes' ) {
				$slave_part .= colored(" !io", "red bold");
			}

			if ( $sql ne 'Yes' ) {
				$slave_part .= colored(" !sql", "red bold");
			}
			$host_line .= $slave_part;
		}

		alarm(2);
		$handle = $cxs{$host}->prepare("show full processlist");
		$handle->execute();
		alarm(0);
		@processlist = ();
		while ( ($h = $handle->fetchrow_hashref()) ) {
			$h->{"real_id"} = $h->{"Id"};
			$h->{"Id"} = $pid_map++;
			push (@processlist, $h);
		} 

		$cx_count = @processlist;	

		$host_line .= colored(" $cx_count cxs", 'white');

		$host_line .= colored(" ($comments{$host})", 'white') if ( $comments{$host} );
	

		#alarm(2);
		#@arr = $cxs{$host}->selectrow_array("show status like 'Questions'");
		#@now = gettimeofday();
		#if ( !$qps{$host} ) {
		#	$qps{$host} = (\@now, $arr[1]);
		#	$qps_now = 0;
		#} else {
		#	$qps_between = $arr[1] - $qps{$host}[1];
		#	$time_between = tv_interval($qps{$host}[0], \@now);
#
#			$qps{$host} = ([gettimeofday()], $arr[1]);
#			printf ("hey, %d -  %d  - %d  - %.2f", $arr[1], $qps{$host}[1], $qps_between, $time_between); 
#		}	
##		#print @arr[1];
#		#alarm(0);


		print colored($host_line, 'white');

		for ( $i = 0 ; $i < $TERM_COLS - 1 - &precolor_length($host_line) - length($host_str); $i++ ) {
			printf "-";
		}
		print "|\n";
			
		my ($q, $d, $count) = &print_mysql($host, \@processlist);
		if ( $wedge{$host} ) {
			&detect_wedge($host, \@processlist);
		}
		foreach $k (keys %$q) {
			$queries->{$k}{'q'} = $q->{$k}{'q'};		
			$queries->{$k}{'real_id'} = $q->{$k}{'real_id'};		
			$queries->{$k}{'db'} = $q->{$k}{'db'};		
			$queries->{$k}{'host'} = $q->{$k}{'host'};		
			$queries->{$k}{'server'} = $q->{$k}{'server'};		
			$queries->{$k}{'state'} = $q->{$k}{'state'};		
			$queries->{$k}{'time'} = $q->{$k}{'time'};		
		}

	}
	print "+";

	for ( $i = 0 ; $i < ($TERM_COLS - 2); $i++ ) {
		printf "-";
	}
	print "+\n";
	$| = 1;

	$key = ReadKey 6;

	if ( !$key ) {
		next;
	} else {
		if ( $key eq 'p' ) {
			$paused = 1;
			ReadMode normal;
			while ( $paused ) {
				print ">";
				$line = ReadLine 0;
				if ( $line =~ /^x\s*(\d+)/ ) {
					print "$1 (" . $queries->{$1}{'real_id'} . ") is being executed by " . $queries->{$1}{'host'} . "\n";
					print "on " . $queries->{$1}{'db'} . "and is in state \"" . $queries{$1}{'state'} . "\"\n";
					print $queries->{$1}{'q'} . "\n";
				} elsif ( $line =~ /^long\s*(off|\d+)?/ ) {
					if ( $1 ) {
						if ( $1 eq 'off' ) {
							$long_running_only = 0;
						} else {
							$long_running_only = $1;
						}
					} else {
						if ( $long_running_only ) {
							$long_running_only = 0;
						} else {
							$long_running_only = 5;
						}
					}
					print "long running queries only " . ($long_running_only ? $long_running_only . " seconds" : "OFF") . "\n";
					sleep(1);
					ReadMode cbreak;
					$paused = 0;
				} elsif ( $line =~ /^l\s*(\S+)/ ) {
					$host = $1;
					print "Dumping connection stats from $host\n";
					next if ( !$cxs{$host} );
				
					$handle = $cxs{$host}->prepare("show processlist");
					$handle->execute();
					my %host_hash;
					while ( ($h = $handle->fetchrow_hashref()) ) {
						my $client = $h->{'Host'};
						$client =~ s/:\d+//;
						$host_hash{$client}++;
					} 
					foreach $x (sort(keys %host_hash)) {
						print $host_hash{$x} . "\t\t$x" . "\n";
					}
				} elsif ( $line =~ /ex\w*\s+(\d+)/ ) {
					$q = $queries->{$1}{'q'};
					$db = $queries->{$1}{'db'};
					$server = $queries->{$1}{'server'};
					if ( $q ) {
						print $q;
						$q =~ s/\`/\\\`/g;
						print("mysql --user=$user -p'$pass' --database=$db --host=$server -e \"explain $q\"");
					}
				} elsif ( $line =~ /^k\w*\s*long\s*(\w*)\s*([\d]*)/i ) {
					$target_host = $1 || undef;
					$max_time = int($2 || 5);
					my ( $i ) = 0;
					my ( @longs );
					foreach $id ( keys %$queries ) {
						next if $queries->{$id}{'time'} < $max_time || $target_host && $queries->{$id}{'server'} ne $target_host;
						next if $queries->{$id}{'q'} =~ /^(insert|update|delete)/i;
						$longs[$i] = $queries->{$id};	
						$i++;
					}
		
					while ( 1 ) {
						for ( $i = 0; $i < @longs; $i++ ) { 
							print colored("[$i]: (" . $longs[$i]{'server'} . ")" . " " . &short_query($longs[$i]{'q'}, 80) . "\n", $i % 2 == 0 ? "white bold" : "reset");
						}
						print "(which? use format of *|1,3,4|1-3,5,6) >";
						$line = ReadLine 0;
						if ($line eq "\n" ) {
							ReadMode cbreak;
							$paused = 0;
							last;
						} else { 
              $ids = split(/,/, $line); 
              my @to_kill;
              foreach $id ( $ids ) { 
                if ( $id =~ /-/ ) { 
                  ($first, $last) = $id.split(/-/);
                  push @to_kill, $first..$last
                }
($id in 

 ( $line eq "*\n" ) {
							my ($k);
							for ($k = 0; $k < @longs; $k++) {
								$server = $longs[$k]{'server'};
								$cmd = "kill " . $longs[$k]{'real_id'};
								print $cmd . "\n";
								$cxs{$server}->do($cmd);
								#splice (@longs, $k, 1);
							}
							
							ReadMode cbreak;
							$paused = 0;
							last;
							sleep(1);

							
						} elsif ( $line =~ /(\d+)/ ) {
							my $k = int($1);
                            $server = $longs[$k]{'server'};
							$cmd = "kill " . $longs[$k]{'real_id'};
							print $cmd . "\n";
							$cxs{$server}->do($cmd);
							splice (@longs, $k, 1);
						}
					}

				} elsif ( $line =~ /^k\s*([\d\s]+)/ ) {
					@ids = split(/\s+/, $1);
					if (@ids) { 
						foreach $id (@ids) {
							print "killing query $id on " . $queries->{$id}{'server'} . " (real pid: " . $queries->{$id}{'real_id'} . "):\n";
							print $queries->{$id}{'q'} . "\n";
						}
						print "Please confirm by typing 'y':\n";
						$line = ReadLine 0;
						
						if ( $line =~ /^[yY]/ ) {
							foreach $id (@ids) {
								$server = $queries->{$id}{'server'};
								$cxs{$server}->do("kill " . $queries->{$id}{'real_id'});	
							}
						}
						ReadMode cbreak;
						$paused = 0;	
					}

				} elsif ( $line =~ /^\s+$/ ) {
					ReadMode cbreak;
					$paused = 0;
				} elsif ( $line eq '' || $line =~ /q\s+$/ ) {
					$quit = 1;
					$paused = 0;
				}
			}	
		} elsif ( $key eq 'q' ) {
			$quit = 1;
		}
	}
}
ReadMode restore

